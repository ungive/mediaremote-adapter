#!/usr/bin/perl
# Copyright (c) 2025 Jonas van den Berg
# This file is licensed under the BSD 3-Clause License.

use strict;
use warnings;
use FindBin;
use File::Spec;
use File::Basename;

my $script_path =
  File::Spec->catfile($FindBin::Bin, '..', 'lib', 'media-control',
  'mediaremote-adapter.pl');
my $framework_path = File::Spec->rel2abs(
  File::Spec->catdir(
    $FindBin::Bin, '..', 'Frameworks', 'MediaRemoteAdapter.framework'
  )
);

#<<<
my @command_list = (
  { name => 'play', id => 0, help => 'Start playback' },
  { name => 'pause', id => 1, help => 'Pause playback' },
  { name => 'toggle-play-pause', id => 2, help => 'Toggle between play and pause' },
  { name => 'stop', id => 3, help => 'Stop playback' },
  { name => 'next-track', id => 4, help => 'Skip to the next track' },
  { name => 'previous-track', id => 5, help => 'Return to the previous track' },
  { name => 'toggle-shuffle', id => 6, help => 'Toggle shuffle mode' },
  { name => 'toggle-repeat', id => 7, help => 'Toggle repeat mode' },
  { name => 'start-forward-seek', id => 8, help => 'Start seeking forward' },
  { name => 'end-forward-seek', id => 9, help => 'Stop seeking forward' },
  { name => 'start-backward-seek', id => 10, help => 'Start seeking backward' },
  { name => 'end-backward-seek', id => 11, help => 'Stop seeking backward' },
  { name => 'go-back-fifteen-seconds', id => 12, help => 'Go back 15 seconds' },
  { name => 'skip-fifteen-seconds', id => 13, help => 'Skip ahead 15 seconds' },
  { name => 'send <ID>', id => undef, help => 'Send a command by its ID' },
);
#>>>

my $basename = basename($0);

sub print_help {
  print <<"HELP";
Example usage:
  $basename get
  $basename stream
  $basename toggle-play-pause
  $basename send 7

Metadata:
  get     Read now playing information once
  stream  Stream updates to now playing information

HELP
  my $commands_title = "Commands:";
  my $description_title = "";
  my $command_id_title = "ID:";
  my $max_name_length = 0;
  foreach my $command (@command_list) {
    my $length = length($command->{name});
    $max_name_length = $length if $length > $max_name_length;
  }
  my $max_help_length = 0;
  foreach my $command (@command_list) {
    my $length = length($command->{help});
    $max_help_length = $length if $length > $max_help_length;
  }
  my $spacing = 2;
  my $padding = 2;
  my $max_name_padding = $max_name_length + $padding;
  my $max_help_padding = $max_help_length + $padding;
  print $commands_title
    . " " x ($max_name_padding - length($commands_title))
    . $description_title
    . " " x ($max_help_padding - length($description_title))
    . $command_id_title."\n";
  foreach my $command (@command_list) {
    my $id = $command->{id};
    my $name = $command->{name};
    my $help = $command->{help};
    my $name_spaces_needed = $max_name_padding - length($name);
    my $help_spaces_needed = $max_help_padding - length($help);
    print"  $name"
      . " " x $name_spaces_needed. "$help"
      . " " x $help_spaces_needed;
    if (defined $id) {
      print $id;
    }
    print"\n";
  }
  print <<"HELP";

HELP
}

sub has_command_id {
  my ($id) = @_;
  foreach my $command (@command_list) {
    if (defined $command->{id} && $command->{id} == $id) {
      return 1;
    }
  }
  return 0;
}

sub fail {
  my ($message) = @_;
  print STDERR "Error: $message\n";
  exit 1;
}

sub fail_if {
  my ($more) = @_;
  if (defined $more) {
    fail "Too many arguments";
  }
}

sub delegate {
  my $name = shift;
  my $id = shift;
  my @args = ($script_path, $framework_path, $name);
  push @args, $id if defined $id;
  exec $^X, @args or die "Failed to execute $script_path: $!";
  exit 0;
}

sub parse_command {
  my $command = shift;
  my $id = shift;
  my $more = shift;
  if ($command eq 'get') {
    fail_if($id);
    delegate($command);
  }
  elsif ($command eq 'stream') {
    fail_if($id);
    delegate($command);
  }
  elsif ($command eq 'send') {
    if (defined $id) {
      if (has_command_id($id)) {
        fail_if($more);
        delegate($command, $id);
      }
      else {
        fail "Unknown ID: $id";
      }
    }
    else {
      fail "Missing ID for command '$command'";
    }
  }
  else {
    my $found = 0;
    foreach my $cmd (@command_list) {
      my $command_id = $cmd->{id};
      if ($cmd->{name} eq $command && defined $command_id) {
        $found = 1;
        fail_if($id);
        delegate("send", $command_id);
      }
    }
    if (!$found) {
      fail "Unknown command '$command'\n";
    }
  }
}

my $command = shift @ARGV or print_help() and exit;
my $id = shift @ARGV;
my $more = shift @ARGV;
if (defined $id && $id !~ /^0$/) {
  $id =~ s/^0+//;
}
if (defined $id && $id !~ /^\d+$/) {
  fail "'$id' is not a valid ID";
}
if ($command eq 'help') {
  print_help();
  exit;
}

parse_command($command, $id, $more);
